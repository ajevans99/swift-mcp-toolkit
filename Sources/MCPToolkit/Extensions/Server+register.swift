import MCP

extension Server {
  /// Registers the provided tools with the MCP server using the recommended handlers.
  ///
  /// The server automatically responds to `tools/list` with metadata generated by each tool's
  /// ``MCPTool/toTool()`` output and wires `tools/call` to ``MCPTool/call(arguments:)``. This
  /// mirrors the behaviour documented in the
  /// [swift-sdk README](https://github.com/modelcontextprotocol/swift-sdk) while removing the
  /// boilerplate for JSON parsing, validation, and error reporting.
  ///
  /// - Parameters:
  ///   - tools: The collection of tools that should be surfaced to MCP clients.
  ///   - messaging: The response messaging provider responsible for formatting toolkit-managed
  ///     responses. Defaults to ``DefaultResponseMessaging``.
  /// - SeeAlso: https://modelcontextprotocol.io/specification/2025-06-18/server/tools
  public func register<M: ResponseMessaging>(
    tools: [any MCPTool],
    messaging: M = DefaultResponseMessaging()
  ) async {
    self.withMethodHandler(ListTools.self) { _ in
      .init(tools: tools.map { $0.toTool() })
    }

    self.withMethodHandler(CallTool.self) { params async in
      guard let tool = tools.first(where: { $0.name == params.name }) else {
        return messaging.unknownTool(
          .init(requestedName: params.name)
        )
      }

      if let arguments = params.arguments {
        do {
          let result = try await tool.call(arguments: arguments, messaging: messaging)
          return result
        } catch {
          return messaging.toolThrew(
            .init(toolName: tool.name, error: error)
          )
        }
      }

      return messaging.missingArguments(
        .init(toolName: tool.name)
      )
    }
  }
}
